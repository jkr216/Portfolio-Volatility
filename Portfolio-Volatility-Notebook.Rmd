---
title: "R Notebook"
output: html_notebook
---

```{r setup, message = FALSE}
library(quantmod)
library(tidyverse)
library(PerformanceAnalytics)
library(xts)
library(tidyquant)
library(purrr)
```

```{r}

symbols <- c("SPY","IJS","EFA","EEM","IEF")

prices <- 
  getSymbols(symbols, src = 'google', from = "2017-01-01", 
             auto.assign = TRUE, warnings = FALSE) %>% 
  map(~Cl(get(.))) %>% 
  reduce(merge) %>%
  `colnames<-`(symbols)

# generate daily return series for funds
returns <-na.omit(ROC(prices, 1, "continuous"))

# portfolio weights
w = c(0.25, 0.20, 0.15, 0.15, 0.25)

# portfolio standard deviation
# transpose of the weights cross prod covariance matrix returns cross prod weights
portfolio_sd <- sqrt(t(w) %*% cov(returns) %*% w)

# marginal contribution to portfolio standard deviation.
marginal_contr_portfolio_sd <- w %*% cov(returns) / portfolio_sd[1,1]

# component contribution to risk 
component_risk_contribution <- marginal_contr_portfolio_sd * w 

component_risk_percentage <- component_risk_contribution / portfolio_sd[1,1]

results <- tibble(symbols, w, as.vector(component_risk_percentage)) %>% 
  rename(weights = w, `risk contribution` = `as.vector(component_risk_percentage)`)


```

```{r}
# Confirm portfolio volatility
portfolio_sd_confirm <- StdDev(returns, weights = w)

# Confirm component contribution to volality.
component_sd_confirm <- StdDev(returns, weights = w, portfolio_method = "component")

# Returns a list, which isn't ideal for presenting. 
str(component_sd_confirm)

# Let's port to a tibble. I am going to transpose because I want them to be in 
# wide format. That will be important when we want to chart later on - we'll get there! 
sd_to_tibble <- as_tibble(t(sd_via_PerfAn$pct_contrib_StdDev)) %>% 
    mutate(date = index(returns)[nrow(returns)]) %>% 
    select(date, everything())
```


```{r}
# Before we get to substance, let's practice toggling between a tibble and an xts. 
# Why? The more this is done, easier it will be to think through the tool kit for
# time series. 

returns_df <- returns %>% 
  as_tibble(preserve_row_names = TRUE) %>% 
  mutate(date = ymd(row.names)) %>% 
  select(-row.names) %>% 
  select(date, everything())

# Another benefit, I can expiremtn with returns_xts without corrupting my
# original data object `returns`.
returns_xts <- returns_df %>% 
  as_xts(date_col = date)


# calculate risk contribution to portfolio with function from PortfolioAnalytics package

my_interval_sd <- function(returns_df, start = 1, window = 20){
  
  # First create start date
  start_date = returns_df$date[start]
  
  # Next an end date
  end_date = returns_df$date[c(start + window)]
  
  # Filter on start and end date
  interval_to_use <- returns_df %>% filter(date >= start_date & date < end_date)
  
  # Convert to xts so can use built in Performance Analytics function.
  returns_xts <- interval_to_use %>% as_xts(date_col = date) 
  
  # Portfolio weights.
  w <- c(0.25, 0.20, 0.15, 0.15, 0.25)
  
  # Pass xts object to function.
  results_as_xts <- StdDev(returns_xts, weights = w, portfolio_method = "component")
  
  # Convert results to tibble.
  results_to_tibble <- as_tibble(t(results_as_xts$pct_contrib_StdDev)) %>% 
    mutate(`end date` = end_date) %>% 
    select(`end date`, everything()) 
}


rolling_sd_test1 <- my_interval_sd(returns_df, 1, 20)
rolling_sd_test2 <- my_interval_sd(returns_df, 2, 20)
rolling_sd_test3 <- my_interval_sd(returns_df, 3, 20)
rolling_sd_test4 <- my_interval_sd(returns_df, 4, 20)
rolling_sd_test5 <- my_interval_sd(returns_df, 5, 20)

bound <- bind_rows(rolling_sd_test1, rolling_sd_test2, rolling_sd_test3, rolling_sd_test4, rolling_sd_test5)

bound

# Applications: subset. rolling. subset by spikes, perhaps whenever x asset went above this threshold for risk contribution. chart the time series. 


rolling_contribution <- function(returns_xts, window = 100){

  rolling_window <- window
  
  w <- c(0.25, 0.20, 0.15, 0.15, 0.25)

  xts_window <- returns_xts[index(returns_xts)[1:rolling_window]] %>% 
    StdDev(., weights = w, portfolio_method = "component")  
  
  xts_to_tibble <-  as_tibble(t(xts_window$pct_contrib_StdDev)) %>% 
    mutate(`end date` = index(returns_xts)[rolling_window]) %>% 
    select(`end date`, everything())
}



```

```{r}
from_scratch <- function(returns_df){
  # Start at observation one.
  # Go to observation one + window
  # using the weights, calculate component standard deviation
  # save in a data frame with components as column names

  # this function will start at 1
  #x.subset <- index(x)[1:window]
  # portfolio weights
  returns_xts <- as_xts(returns_df, date_col = date) 
  w <- c(0.25, 0.20, 0.15, 0.15, 0.25)
  #returns_chopped <- x[x.subset] %>% as_tibble()
  
  results <- StdDev(returns_xts, weights = w, portfolio_method = "component") 
  results <- as_tibble(t(results$pct_contrib_StdDev))
}
```


```{r}

#port.VaR <- VaR(returns, weights = w, portfolio_method = "component")

test_df <- data_frame(names(port.sd$contribution)) %>% mutate(contribution = port.sd$contribution, perct_contr = port.sd$pct_contrib_StdDev)

colnames(test_df)[1] <- "asset"

per_an <- ggplot(test_df, aes(asset, contribution)) +
  geom_col(fill = 'blue', colour = 'red')+ scale_y_continuous(labels = percent)

library(scales)

by_hand <-ggplot(results, aes(Tickers, Component)) +
  geom_col(fill = 'blue', colour = 'red') + scale_y_continuous(labels = percent)
per_an
by_hand
```


```{r Find Min Variance Portfolio}
symbols_min <- c("SPY","IJS","EFA", "FB")
prices_min <- 
  getSymbols(symbols_min, src = 'google', from = "2017-01-01", 
             auto.assign = TRUE, warnings = FALSE) %>% 
  map(~Cl(get(.))) %>% 
  reduce(merge) %>%
  `colnames<-`(symbols_min)

# generate daily return series for funds
returns_min <- na.omit(ROC(prices_min, 1, "continuous"))

 mu_returns <- colMeans(returns_min)
 
 covriance_matrix_min <- cov(returns_min)
 
 top_matrix_min <- bind_cols(2*covriance_matrix_min, rep(1, 4))
 
 bot_vector_min <- c(rep(1, 4), 0)
 
 Am_mat_min <- bind_rows(top_matrix_min, bot_vector_min)
 
 b_vec_min <- c(rep(0, 4), 1)
 
 z_m_mat_min <- solve(Am_mat_min) %*% b_vec_min
 
 m_vec_min <- z_m_mat_min[1:4,1]
 m_vec_min
 mu_min_port <- as.numeric(crossprod(m_vec_min, mu_returns))

# portfolio variance
min_port_var <- as.numeric(t(m_vec_min) %*% covriance_matrix_min %*% m_vec_min)

```






