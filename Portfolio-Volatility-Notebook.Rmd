---
title: "R Notebook"
resource_files:
- function-folder/helpers.r
output: html_notebook
---

```{r setup, message = FALSE}
library(quantmod)
library(tidyverse)
library(PerformanceAnalytics)
library(xts)
library(tidyquant)
library(plotly)
```

```{r}

symbols <- c("SPY","IJS")

prices <- 
  getSymbols(symbols, src = 'google', from = "2017-01-01", 
             auto.assign = TRUE, warnings = FALSE) %>% 
  map(~Cl(get(.))) %>% 
  reduce(merge) %>%
  `colnames<-`(symbols)

# generate daily return series for funds
returns <-na.omit(ROC(prices, 1, "continuous"))

# portfolio weights
w = c(0.5, 0.5)

# Build covariance matrix
cov_matrix <- cov(returns)
correlation_matrix <- cor(returns)
nms <- names(cov_matrix)
plot_ly(x = nms, y = nms, z = cov_matrix, 
            key = cov_matrix, type = "heatmap", source = "heatplot") %>%
      layout(xaxis = list(title = ""), 
             yaxis = list(title = ""))
```

```{r}

# portfolio standard deviation
# transpose of the weights cross prod covariance matrix returns cross prod weights
portfolio_sd <- sqrt(t(w) %*% cov_matrix %*% w)

# marginal contribution to portfolio standard deviation.
marginal_contr_portfolio_sd <- w %*% cov(returns) / portfolio_sd[1,1]

# component contribution to risk 
component_risk_contribution <- marginal_contr_portfolio_sd * w 

# To get the percentage contribution, divide component contribution by total sd.
component_risk_percentage <- component_risk_contribution / portfolio_sd[1,1]

results <- tibble(symbols, w, as.vector(component_risk_percentage)) %>% 
  rename(weights = w, `risk contribution` = `as.vector(component_risk_percentage)`)


```

```{r}
# Confirm portfolio volatility
portfolio_sd_confirm <- StdDev(returns, weights = w)

# Confirm component contribution to volality.
component_sd_confirm <- StdDev(returns, weights = w, portfolio_method = "component")

# Returns a list, which isn't ideal for presenting. 
str(component_sd_confirm)

# Let's port to a tibble. I am going to transpose because I want them to be in 
# wide format. That will be important when we want to chart later on - we'll get there! 
sd_to_tibble <- as_tibble(t(sd_via_PerfAn$pct_contrib_StdDev)) %>% 
    mutate(date = index(returns)[nrow(returns)]) %>% 
    select(date, everything())
```


```{r}
# Before we get to substance, let's practice toggling between a tibble and an xts. 
# Why? The more this is done, easier it will be to think through the tool kit for
# time series. 

returns_df <- returns %>% 
  as_tibble(preserve_row_names = TRUE) %>% 
  mutate(date = ymd(row.names)) %>% 
  select(-row.names) %>% 
  select(date, everything())

# Another benefit, I can expirement with returns_xts without corrupting my
# original data object `returns`.
returns_xts <- returns_df %>% 
  as_xts(date_col = date)
returns_xts[,"SPY"]
```

```{r SD Interval Function, message = FALSE}
# calculate risk contribution to portfolio with function from PortfolioAnalytics package

my_interval_sd <- function(returns_df, start = 1, weights, window = 20){
  
  # First create start date
  start_date = returns_df$date[start]
  
  # Next an end date
  end_date = returns_df$date[c(start + window)]
  
  # Filter on start and end date
  interval_to_use <- returns_df %>% filter(date >= start_date & date < end_date)
  
  # Convert to xts so can use built in Performance Analytics function.
  returns_xts <- interval_to_use %>% as_xts(date_col = date) 
  
  # Portfolio weights.
  w <- weights
  
  # Pass xts object to function.
  results_as_xts <- StdDev(returns_xts, weights = w, portfolio_method = "component")
  
  # Convert results to tibble.
  results_to_tibble <- as_tibble(t(results_as_xts$pct_contrib_StdDev)) %>% 
    mutate(date = ymd(end_date)) %>% 
    select(date, everything()) 
}
```

```{r Use the function, message = FALSE, warning = FALSE}
rolling_sd_test1 <- my_interval_sd(returns_df, 1, 20)
rolling_sd_test2 <- my_interval_sd(returns_df, 2, 20)
rolling_sd_test3 <- my_interval_sd(returns_df, 3, 20)
rolling_sd_test4 <- my_interval_sd(returns_df, 4, 20)
rolling_sd_test5 <- my_interval_sd(returns_df, 5, 20)

bound <- bind_rows(rolling_sd_test1, rolling_sd_test2, rolling_sd_test3, rolling_sd_test4, rolling_sd_test5)

# need an input for
# window, weights, stocks
window <- 20
weights <- w

test <- map_df(1:(nrow(returns_df)-window), my_interval_sd, 
               returns_df = returns_df, weights = weights, window = window) %>%
  mutate_all(funs(round(., 3))) %>%
  mutate(date = ymd(date)) %>% 
  select(date, everything()) %>% 
  as_xts(date_col = date)
test
```


```{r, message = FALSE}
library(highcharter)

 vis <- highchart(type = "stock") %>% 
   hc_title(text = "Volatility Contribution") %>%
   hc_add_series(test[, 1], name = "SPY Risk Comp") %>%
   hc_add_series(test$IJS, name = "IJS Risk Comp") %>%
   hc_add_series(test$EFA, name = "EFA Risk Comp" )%>%
   hc_add_series(test$IEF, name = "IEF Risk Comp") %>%
   hc_add_series(test$EEM, name = "EEM Risk Comp") %>%
    # I don't like the look of the navigator/scrollbar, but you might. 
    # Change these to enabled = TRUE and check out the results.
    hc_navigator(enabled = FALSE) %>% 
    hc_scrollbar(enabled = FALSE)
 vis
```


Applications: 
-subset. 
-rolling. 
-subset by spikes, perhaps whenever x asset went above this threshold for risk contribution.
-label any cross overs
-try to explain when a certain goes above the thresh
-calculate portfolio that puts to parity at time x
-chart the time series. 



```{r}
rolling_contribution <- function(returns_xts, window = 100){

  rolling_window <- window
  
  w <- c(0.25, 0.20, 0.15, 0.15, 0.25)

  xts_window <- returns_xts[index(returns_xts)[1:rolling_window]] %>% 
    StdDev(., weights = w, portfolio_method = "component")  
  
  xts_to_tibble <-  as_tibble(t(xts_window$pct_contrib_StdDev)) %>% 
    mutate(`end date` = index(returns_xts)[rolling_window]) %>% 
    select(`end date`, everything())
}

```


```{r visualize volatility}

#port.VaR <- VaR(returns, weights = w, portfolio_method = "component")

test_df <- data_frame(names(port.sd$contribution)) %>% mutate(contribution = port.sd$contribution, perct_contr = port.sd$pct_contrib_StdDev)

colnames(test_df)[1] <- "asset"

per_an <- ggplot(test_df, aes(asset, contribution)) +
  geom_col(fill = 'blue', colour = 'red')+ scale_y_continuous(labels = percent)

library(scales)

by_hand <-ggplot(results, aes(Tickers, Component)) +
  geom_col(fill = 'blue', colour = 'red') + scale_y_continuous(labels = percent)
per_an
by_hand
```







